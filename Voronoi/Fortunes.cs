using System;
using System.Collections.Generic;

namespace Voronoi
{
    /**
     * Holy legacy code batman!
     * C @author Steven Fortune
     * C++ @author Shane O'Sullivan
     * Java @author Ryan Minor
     * C# @author Ryan Minor
     * 
     * Structs carried over from C++>Java code: 
     * 	Freenode. Knows next node. Implemented
     * 	FreeNodeArrayList. Knows current and next node. Implemented
     * 	FreeList. Knows head and size. Replaced with ArrayList
     * 	Point. x,y. Using Java's 2D > In C#, had to make own. Basically a quicker copy of it
     * 	Site. Stores a coord and 2 points. Implemented
     * 	Edge. Stores 3 doubles, 2 arrays of size 2 of sites, and one int. Implemented
     * 	Graphedge. Stores 2 x/y coords and a next graphedge.
     */

    public class Fortunes
    {
        private int _siteidx;
        private Site[] _sites;
        private int _nsites;
        private Halfedge _elLeftend, _elRightend;
        private int _elHashsize;
        private double _xmax, _ymax, _deltax, _deltay;
        private int _sqrtNsites;
        private Site _bottomsite;
        private int _pqHashsize;
        private Halfedge[] _pqHash;
        private int _pqCount;
        private int _pqMin;
        private double _pxmin, _pxmax, _pymin, _pymax;
        private double _borderMinX, _borderMaxX, _borderMinY, _borderMaxY;
        private GraphEdge _allEdges;
        private GraphEdge _iteratorEdges;
        private double _minDistanceBetweenSites;
        private Halfedge[] _elHash;

        private class Site
        {
            public readonly Point2D Coord;

            public Site(Point2D p)
            {
                Coord = p;
            }
        }

        /**
         * Who makes a language without native 2D support?
         * We are using the vector library to do all the fancy math stuff. We need to make a private class and add our numbers to it
         */
        private class Point2D
        {
            internal double X { get;}
            internal double Y { get;}
            
            public Point2D(double x, double y)
            {
                X = x;
                Y = y;
            }

            public double Distance(Point2D botCoord)
            {
                //A^2 + B^2 = C^2
                var a = Math.Pow(botCoord.X - X, 2);
                var b = Math.Pow(botCoord.Y - Y, 2);
                return Math.Sqrt(a + b);
            }
        }

        private class Edge
        {
            public double A;
            public double B;
            public double C;
            public readonly Site[] Ep;
            public readonly Site[] Reg;

            internal Edge()
            {
                Ep = new Site[2];
                Reg = new Site[2];
            }
        }

        private class GraphEdge
        {
            public readonly Point2D P1;
            public readonly Point2D P2;
            public readonly GraphEdge Next;

            public GraphEdge(Point2D p1, Point2D p2, GraphEdge n)
            {
                P1 = p1;
                P2 = p2;
                Next = n;
            }
        }

        private class Halfedge
        {
            public Halfedge ElLeft;
            public Halfedge ElRight;
            public Edge ElEdge;
            public int ElPm;
            public Site Vertex;
            public double YStar;
            public Halfedge PqNext;
        }

        public Fortunes()
        {
            _siteidx = 0;
            _allEdges = null;
            _iteratorEdges = null;
            _minDistanceBetweenSites = 0;
        }

        public static void Run()
        {
            var fortune = new Fortunes();
            const double max = 5000;
            const double minDist = 1;

            var xValues = new double[] { 2450, 4908, 3607, 1402, 1125, 709, 3022, 3360, 4161, 3923, 3378, 2920, 24, 1388, 2946, 2953, 2323, 3834, 3549, 2557, 4488, 4432, 3490, 746, 4053, 876, 4932, 3986, 2140, 1487, 3642, 4194, 458, 3650, 3175, 3037, 634, 180, 36, 3586, 4861, 2157, 1606, 303, 4122, 1684, 2276, 2048, 1522, 3074, 130, 692, 1389, 1337, 4686, 4734, 2564, 4703, 151, 4611, 3973, 1974, 4655, 2002, 4021, 4, 666, 1145, 3132, 4684, 1862, 1082, 3427, 1937, 998, 1154, 552, 2997, 4092, 4716, 20, 4115, 454, 322, 3768, 1746, 4571, 3827, 45, 1208, 3927, 4492, 2645, 4589, 3819, 1383, 1367, 1561, 4967, 4044, 996, 526, 4845, 2940, 1397, 1758, 1053, 3570, 2906, 1848, 4045, 3687, 3680, 337, 2371, 4639, 1106, 2082, 155, 3323, 4470, 1455, 3090, 1657, 4174, 1620, 4670, 421, 887, 2822, 1194, 3053, 2509, 2603, 2968, 995, 2560, 2670, 4428, 2395, 4922, 3081, 3325, 4210, 2884, 1120, 5, 3518, 4142, 3863, 1590, 4830, 4955, 3149, 2451, 1361, 1589, 171, 4945, 4859, 4222, 3043, 3431, 3485, 1302, 2579, 3765, 3695, 2607, 3774, 1202, 4379, 1338, 3072, 4252, 4341, 1537, 2163, 2669, 4400, 4628, 243, 2593, 4731, 1479, 1861, 1255, 899, 4654, 4296, 3459, 837, 2433, 133, 2162, 363, 606, 1482, 2363, 272, 3125, 1538, 1688, 140, 2690, 945, 3044, 3510, 3836, 2005, 2901, 4897, 499, 1695, 1190, 4304, 665, 1090, 1359, 1934, 4884, 163, 2708, 1730, 2017, 3898, 316, 3852, 2281, 1640, 4090, 333, 4730, 627, 3698, 583, 1420, 3265, 338, 4202, 403, 779, 3463, 3862, 2385, 2517, 4711, 64, 1525, 3012, 3092, 254, 2079, 633, 4843, 1762, 2864, 1621, 1665, 3128, 2737, 2770, 4647, 1516, 4910, 1984, 2807, 1287, 1002, 4477, 4067, 4807, 3001, 3304, 1629, 318, 4506, 284, 1477, 678, 1164, 2292, 3657, 1775, 3118, 3095, 1627, 4048, 3108, 2299, 437, 4095, 2506, 1211, 324, 1826, 3968, 4335, 2013, 1094, 232, 1450, 3847, 3328, 4815, 2635, 390, 1028, 1396, 2993, 4833, 2899, 3361, 3901, 216, 2453, 1724, 4129, 1131, 4882, 4223, 3754, 818, 2836, 4084, 3764, 3539, 3731, 55, 4662, 371, 2137, 1624, 4561, 1922, 423, 3769, 3307, 2681, 3802, 2165, 524, 1952, 4349, 2230, 1726, 2723, 869, 2088, 97, 4178, 225, 790, 1653, 3481, 2965, 3933, 2026, 2063, 3292, 4873, 1423, 3814, 4123, 2581, 2416, 4120, 1223, 4750, 892, 4557, 4522, 3596, 4598, 2663, 277, 1207, 2801, 3506, 2121, 129, 4708, 1733, 3223, 2753, 3116, 3830, 3554, 4863, 4113, 938, 1721, 135, 1466, 4131, 3105, 3403, 3798, 2123, 3031, 1669, 867, 2962, 2329, 1697, 472, 3841, 250, 3397, 290, 736, 4360, 3436, 3148, 4183, 2784, 1218, 4068, 384, 3115, 4919, 1023, 70, 712, 4781, 2212, 868, 2958, 4358, 4238, 2573, 1656, 3761, 3305, 2540, 115, 1872, 2799, 976, 854, 2487, 4266, 4853, 2599, 4993, 141, 1761, 3935, 3651, 305, 1407, 3582, 2785, 563, 1073, 1795, 2772, 4927, 4421, 4290, 2693, 3077, 4466, 2615, 832, 1905, 1683, 672, 1258, 1860, 1840, 3439, 1447, 230, 3606, 1129, 1649, 31, 621, 168, 701, 2907, 3386, 2947, 3840, 3904, 3114, 4827, 4844, 1809, 1749, 2531, 1722, 2334, 724, 1734, 3370, 3445, 2629, 4658, 4573, 3787, 4278, 2120, 3891, 3091, 849, 2530, 3983, 1935, 2417, 3271, 4802, 2922, 3928, 517, 1880, 2960, 2133, 4012, 413, 3545, 4975, 1565, 3242, 3442, 3745, 650, 2842, 3003, 2592, 2555, 279, 2878, 1404, 4025, 625, 4712, 240, 1894, 2043, 2373, 2628, 2992, 4203, 1823, 3568, 4823, 1978, 3857, 3382, 3434, 4206, 2036, 763, 3541, 4947, 3124, 922, 1111, 603, 1087, 109, 3529, 2511, 4342, 4986, 4917, 3477, 2535, 1071, 3660, 3597, 3054, 4332, 3580, 1947, 1380, 2145, 4880, 3133, 777, 2583, 856, 2303, 3448, 4383, 2971, 2426, 2590, 2028, 1596, 1723, 231, 4366, 3876, 3127, 4970, 2198, 2059, 2711, 2191, 2432, 824, 4069, 654, 2394, 1817, 2626, 988, 2236, 710, 4103, 1743, 905, 3794, 4152, 2100, 4275, 1877, 1550, 4177, 1265, 2064, 3679, 4591, 739, 4448, 2268, 3040, 1415, 2838, 2779, 597, 2525, 1631, 237, 2192, 948, 2497, 715, 623, 335, 1615, 3225, 1364, 4737, 4839, 3697, 4752, 4382, 1281, 1172, 2659, 1062, 1768, 946, 3800, 360, 4665, 1035, 2589, 2857, 2338, 620, 4717, 3848, 685, 52, 3704, 1603, 1320, 2369, 2761, 3533, 1936, 4440, 3432, 4636, 3426, 4651, 4801, 3140, 2775, 770, 1507, 4410, 3897, 1384, 2124, 536, 4631, 2340, 3288, 229, 4992, 4433, 4262, 4648, 2374, 1827, 1054, 1459, 114, 13, 4723, 4415, 928, 1897, 3831, 1794, 1197, 4150, 75, 3209, 1252, 573, 4312, 2377, 924, 4580, 817, 716, 1614, 2570, 4696, 3591, 3628, 1582, 2898, 4489, 3100, 1063, 937, 3749, 1100, 4724, 2709, 3344, 4852, 331, 3789, 1607, 2655, 1585, 111, 2368, 4934, 1014, 407, 2169, 2894, 1178, 1673, 4241, 205, 4804, 4072, 1009, 1462, 1476, 732, 1641, 39, 1041, 1432, 2187, 680, 608, 200, 2680, 1593, 2604, 3618, 570, 616, 349, 718, 2114, 2434, 3824, 447, 1280, 3034, 2503, 3829, 3471, 434, 4706, 4984, 2061, 3584, 2420, 473, 4775, 1998, 1572, 3337, 3514, 4204, 3076, 504, 1879, 2974, 3262, 1878, 4035, 1745, 1124, 4982, 3994, 1116, 1735, 2810, 3667, 2263, 3736, 2892, 1138, 3574, 2138, 2683, 3117, 4630, 1273, 3563, 2706, 1932, 3205, 3357, 451, 1333, 4082, 1099, 1494, 4851, 1032, 1470, 4480, 2012, 4824, 929, 4964, 1852, 1163, 112, 615, 547, 1074, 3049, 1645, 2166, 516, 1725, 2874, 3283, 3826, 2308, 4959, 3962, 1005, 2975, 3326, 3188, 2452, 797, 4390, 4502, 126, 1536, 2813, 85, 1824, 889, 33, 2197, 4459, 4062, 4377, 4816, 4258, 4559, 1386, 365, 708, 4549, 2617, 4825, 3163, 4029, 2996, 1425, 1943, 410, 1564, 3866, 645, 4531, 438, 61, 443, 2094, 2233, 3645, 32, 4634, 270, 4078, 3559, 1454, 1502, 1581, 1427, 1949, 4467, 267, 2227, 713, 26, 4675, 4316, 3101, 1828, 2404, 4016, 4808, 815, 1805, 3042, 311, 2288, 3217, 1843, 3200, 4939, 99, 1303, 4010, 4108, 1712, 3324, 3809, 2588, 119, 4001, 515, 644, 1137, 1718, 4604, 756, 2646, 923, 1237, 4810, 1962, 4351, 1183, 1926, 2065, 3466, 4303, 2311, 1831, 1068, 519, 1604, 4874, 4251, 2954, 3585, 3358, 4520, 1752, 409, 3158, 3416, 4963, 2141, 4201, 4656, 2586, 3773, 248, 1534, 3197, 2091, 2988, 2302, 1663, 3992, 2638, 2285, 1316, 3048, 1916, 2741, 895, 1410, 4777, 3649, 4618, 4350, 79, 2294, 753, 2549, 593, 3507, 2740, 385, 4977, 1201, 1070, 4538, 1416, 4285, 107, 2794, 16, 4733, 4219, 2747, 3008, 3578, 4365, 459, 271, 877, 4211, 1335, 4842, 4297, 2500, 2596, 4077, 4979, 2685, 4182, 3383, 2660, 2108, 3982, 2994, 1161, 4147, 4607, 4597, 4968, 367, 2436, 1118, 3165, 699, 4495, 913, 1114, 2914, 314, 999, 2438, 2710, 3169, 738, 925, 1199, 4431, 1994, 3910, 1764, 3790, 160, 1521, 2981, 1485, 297, 4972, 1950, 2209, 2193, 3122, 4689, 4236, 882, 1526, 1609, 951, 1149, 4027, 1045, 3543, 1587, 980, 4446, 2194, 757, 1968, 2271, 4408, 580, 2762, 4524, 4721, 864, 4952, 4020, 4363, 2112, 888, 3885, 546, 4669, 1362, 1123, 4555, 2083, 3886, 1907, 1392, 3096, 2424, 2700, 1927, 2880, 3640, 1885, 4739, 3974, 4577, 4165, 2181, 3694, 841, 682, 1720, 3458, 3244, 1375, 2984, 1292, 1773, 204, 2419, 3615, 2219, 3412, 142, 3373, 4260, 3515, 3372, 550, 3250, 4818, 1672, 4443, 3409, 3381, 3371, 4043, 2945, 3569, 514, 577, 910, 149, 3440, 1474, 157, 1990, 2915, 1115, 4854, 4188, 485, 1042, 1584, 330, 353, 4317, 3635, 3966, 2948, 794, 453, 3612, 8, 1439, 108, 2809, 4736, 4953, 1890, 4148, 1279, 2734, 2679, 1300, 3839, 1048, 3497, 4855, 1408, 2232, 2384, 953, 4460, 476, 4091, 852, 2087, 1027, 3700, 647, 500, 829, 2765, 4600, 3038, 2501, 3139, 768, 3219, 1928, 2252, 2027, 483, 2437, 1552, 3784, 221, 1437, 3318, 1457, 49, 214, 4776, 4560, 833, 4132, 1731, 3106, 2111, 1221, 3136, 3, 2591, 3407, 3153, 1599, 3210, 750, 1496, 3707, 4191, 2183, 3454, 4512, 4484, 1401, 2397, 1483, 17, 3170, 2632, 4200, 3286, 488, 761, 3035, 1807, 3410, 3417, 3083, 2566, 4060, 4806, 3976, 3632, 2677, 3536, 462, 2086, 4364, 4213, 2792, 2354, 4809, 2695, 7, 686, 4279, 73, 3952, 3230, 565, 4247, 834, 2080, 3949, 2571, 3557, 4372, 2584, 871, 1275, 4435, 748, 3332, 259, 3913, 1243, 1346, 1776, 47, 283, 636, 3185, 553, 3919, 2952, 3329, 4134, 4017, 4935, 1921, 2773, 3456, 571, 3310, 3270, 4501, 4087, 1709, 3589, 3716, 4976, 4900, 2132, 1290, 4170, 2688, 2768, 808, 4217, 1703, 3234, 3422, 1091, 2004, 4998, 4083, 1976, 1849, 10, 3277, 2691, 3903, 667, 4472, 2159, 994, 1960, 3151, 4256, 121, 3306, 855, 4225, 4862, 1541, 1433, 2927, 890, 1307, 414, 733, 3272, 2134, 4461, 1658, 4476, 1815, 3006, 4569, 3953, 1139, 3287, 4898, 4265, 4137, 1941, 4779, 1886, 3845, 1353, 2119, 1214, 3785, 113, 3050, 4081, 632, 1955, 2924, 1601, 796, 2228, 985, 3067, 984, 2715, 950, 4732, 4494, 2435, 1029, 1460, 2905, 820, 2175, 1430, 3552, 2449, 312, 1001, 2789, 1517, 1874, 2963, 3728, 800, 3812, 1702, 448, 3119, 1395, 1059, 3495, 2534, 3732, 4551, 4872, 1997, 4051, 3009, 963, 858, 1249, 1700, 4451, 2486, 2447, 949, 1841, 4055, 847, 4528, 4535, 2759, 1309, 2846, 4796, 4482, 2042, 3368, 2876, 3671, 4151, 3737, 1989, 4612, 2207, 2441, 4722, 3355, 628, 1176, 564, 388, 2033, 2279, 3981, 3202, 2154, 3877, 4404, 4239, 1634, 2422, 4064, 346, 1910, 4710, 1026, 4671, 2957, 979, 2184, 3068, 354, 4107, 464, 426, 4757, 341, 3450, 183, 4099, 4610, 934, 781, 4471, 2144, 978, 1810, 1406, 1664, 387, 65, 2689, 4187, 4430, 4280, 2468, 4965, 1203, 2889, 2496, 3777, 2273, 2858, 3617, 4960, 3330, 2787, 3065, 2415, 412, 906, 2249, 1853, 2633, 4688, 825, 2355, 2754, 4208, 1155, 541, 4393, 4392, 4311, 2746, 3770, 176, 2021, 4661, 4166, 2548, 1403, 1021, 2921, 3719, 2473, 3663, 2146, 4792, 3998, 1576, 3376, 2614, 1859, 4273, 2366, 3207, 4274, 1196, 760, 839, 2913, 4061, 3145, 2563, 3880, 3228, 1820, 3884, 3894, 3232, 4112, 4682, 1508, 336, 4294, 2164, 4933, 2040, 1419, 263, 4321, 3487, 3063, 4305, 3555, 4912, 4276, 2610, 1915, 4826, 2845, 468, 6, 3341, 1930, 494, 1642, 2089, 1046, 1278, 1547, 3776, 2238, 3875, 1715, 3705, 1782, 1283, 4819, 3579, 3740, 3759, 706, 3867, 3609, 1632, 77, 2110, 3263, 2365, 1835, 759, 2825, 2485, 170, 493, 1871, 4782, 3771, 1374, 2526, 2038, 4100, 1322, 2652, 397, 1834, 91, 844, 2050, 4626, 3438, 3333, 2848, 693, 202, 4307, 2459, 1025, 4398, 300, 3138, 2739, 479, 3676, 4981, 3121, 4553, 2425, 4300, 4582, 860, 2863, 182, 769, 2239, 1892, 3713, 1126, 2131, 4336, 3423, 4741, 4023, 3002, 98, 1311, 4623, 4270, 4831, 4380, 3236, 635, 1467, 1490, 3535, 725, 1940, 2412, 364, 511, 626, 1453, 2208, 211, 4436, 909, 3978, 4331, 2014, 4774, 446, 4529, 902, 629, 2344, 2803, 428, 2550, 3739, 4395, 747, 2991, 2240, 2341, 192, 3314, 4987, 1334, 3850, 714, 2547, 542, 2834, 2707, 4523, 2664, 1808, 4215, 2764, 4850, 592, 4556, 2833, 1259, 4664, 4447, 694, 40, 2301, 2471, 110, 411, 1863, 2812, 3620, 3088, 4546, 1909, 227, 2186, 508, 4168, 974, 1212, 2116, 2751, 4088, 3184, 2536, 544, 4533, 721, 3788, 1667, 3392, 2937, 1668, 4870, 3516, 2093, 622, 723, 2241, 966, 4846, 4227, 771, 4537, 4179, 1876, 3166, 4292, 1704, 2647, 1569, 916, 3530, 2977, 2512, 1911, 3508, 982, 2370, 3266, 1680, 1613, 3321, 4345, 3980, 2049, 3010, 1160, 4755, 42, 3015, 1146, 3674, 2883, 4920, 3147, 3172, 585, 3682, 295, 4195, 487, 122, 1117, 442, 4056, 4145, 1929, 4427, 648, 307, 1144, 1577, 1228, 2541, 1267, 1295, 2499, 1224, 1956, 3611, 2326, 4923, 1643, 4140, 1448, 915, 3932, 1973, 3729, 3970, 1044, 4539, 3331, 1013, 703, 43, 4985, 2817, 455, 2235, 639, 2051, 711, 2918, 1288, 1463, 903, 3211, 1812, 2216, 3920, 735, 2796, 1729, 3967, 674, 2494, 2850, 2665, 4858, 2103, 477, 1409, 3633, 704, 1198, 1272, 402, 729, 3216, 4519, 3662, 1148, 3893, 224, 4989, 719, 2704, 3388, 177, 2491, 2585, 3691, 1813, 1428, 1294, 288, 482, 445, 2322, 1188, 4141, 3421, 1748, 4886, 1651, 2391, 1412, 153, 3173, 4642, 3362, 4895, 630, 4416, 4958, 921, 2865, 1646, 1699, 4643, 2375, 4605, 1150, 4513, 3821, 3592, 4413, 4954, 4235, 3062, 1205, 1104, 1771, 4869, 2481, 1774, 3647, 932, 3854, 4649, 3274, 2805, 3926, 444, 4197, 2316, 3189, 3670, 3744, 1222, 4011, 3252, 3881, 776, 430, 4220, 3956, 3690, 90, 3504, 549, 3600, 4070, 4507, 2383, 1331, 2085, 4890, 4119, 684, 2726, 3245, 919 };
            var yValues = new double[] { 3564, 3547, 2010, 1734, 1349, 2827, 4801, 2760, 3109, 581, 4646, 1847, 4189, 3308, 2358, 3465, 4902, 2413, 3656, 3326, 3703, 4555, 1924, 2734, 3450, 4256, 2890, 3640, 2272, 508, 1183, 1837, 2801, 3247, 4309, 576, 3821, 4167, 2319, 4041, 1817, 1616, 2580, 3973, 1600, 2592, 4596, 3271, 1517, 1087, 2633, 3514, 2705, 1690, 3834, 3430, 2942, 2921, 1810, 3562, 4142, 3686, 3206, 1381, 3556, 682, 3148, 2238, 1004, 4004, 4447, 4637, 2606, 708, 3144, 2350, 1853, 992, 4904, 2318, 46, 2556, 4749, 2950, 768, 2597, 3926, 2378, 4678, 4417, 205, 2287, 4729, 2392, 4603, 4231, 1472, 1816, 849, 1495, 4911, 4804, 266, 3296, 1563, 1725, 904, 2280, 3794, 2541, 2441, 1129, 307, 2869, 4040, 4218, 4311, 3763, 2311, 3010, 4090, 499, 2224, 3277, 3589, 1638, 282, 1891, 3256, 3065, 3683, 229, 3466, 4121, 3874, 278, 1229, 3355, 4071, 1310, 826, 3639, 1724, 892, 1363, 4286, 4687, 4968, 4050, 1633, 4137, 4996, 2907, 1116, 4988, 2000, 3524, 1639, 3917, 1674, 3525, 2667, 420, 4091, 1169, 407, 3031, 4781, 79, 1929, 2630, 3197, 4913, 3483, 3289, 4193, 442, 4975, 2551, 2151, 3649, 3807, 2103, 2086, 4439, 192, 4253, 1625, 390, 827, 3105, 1211, 21, 676, 1314, 1388, 2761, 2194, 4788, 4705, 4455, 2557, 2855, 2584, 3964, 4022, 3617, 1483, 949, 3751, 4616, 3868, 562, 2306, 1347, 3506, 3234, 4435, 2595, 261, 4187, 1488, 286, 4761, 1821, 1521, 1797, 1670, 1531, 2417, 2024, 2022, 4350, 2188, 439, 2307, 1909, 4907, 3954, 1999, 846, 1848, 1172, 3740, 4459, 475, 2641, 2789, 1746, 4013, 3856, 4833, 4421, 4846, 353, 570, 1176, 2328, 2782, 1696, 3985, 52, 1854, 3389, 1603, 1737, 4734, 2205, 716, 4297, 4410, 3370, 4873, 4641, 1944, 197, 3797, 1730, 3890, 2345, 3488, 1566, 1077, 4284, 2940, 2500, 2467, 634, 2334, 4863, 1655, 191, 4428, 2191, 3959, 1298, 1671, 174, 78, 2512, 2876, 2978, 3442, 4188, 4807, 3399, 1957, 2340, 2613, 2162, 4655, 4934, 1348, 2697, 3974, 3403, 2680, 4453, 359, 1868, 3040, 1370, 1978, 31, 3346, 2539, 2807, 300, 4552, 3221, 1977, 372, 901, 1050, 791, 4947, 2405, 2234, 1570, 4113, 1079, 1584, 4276, 589, 1421, 1959, 1840, 905, 4384, 36, 245, 4190, 110, 3125, 2146, 183, 4317, 4620, 2093, 2765, 1477, 294, 1227, 2447, 3641, 4806, 3962, 1513, 763, 54, 147, 4558, 3754, 4691, 3494, 785, 3130, 3889, 1630, 3723, 533, 1071, 2965, 580, 2608, 3513, 1988, 2656, 4898, 3376, 3219, 611, 3139, 4581, 939, 2189, 3546, 598, 4479, 597, 352, 3230, 2410, 4544, 2403, 4535, 45, 1204, 4510, 2314, 586, 2386, 3265, 3043, 3845, 2157, 1380, 1885, 4875, 3318, 4622, 2062, 3386, 4987, 4097, 794, 4422, 1326, 3786, 2989, 74, 4287, 3895, 503, 4684, 699, 1163, 3138, 4607, 942, 2586, 3533, 1926, 1801, 4969, 1356, 143, 2999, 923, 860, 4333, 2089, 2850, 367, 2749, 902, 3240, 3720, 150, 1953, 3553, 4198, 269, 4265, 433, 1545, 3721, 2041, 1267, 1694, 2200, 543, 1934, 981, 4604, 366, 248, 4243, 3200, 2732, 3575, 1089, 4469, 3752, 453, 4697, 333, 674, 4302, 3684, 3843, 1304, 389, 1049, 2768, 3359, 2796, 539, 431, 2629, 3771, 3941, 994, 1940, 692, 3711, 2779, 777, 326, 379, 4338, 3272, 1308, 4239, 2969, 1683, 2270, 2754, 2721, 780, 392, 1994, 1508, 954, 1418, 51, 717, 4150, 477, 4096, 2017, 11, 2109, 929, 3402, 3572, 4821, 3910, 1213, 507, 2208, 1900, 77, 917, 3804, 877, 2422, 2228, 1530, 4056, 2096, 4474, 4012, 898, 2636, 1751, 3670, 3092, 2029, 2770, 2265, 742, 552, 1207, 238, 1419, 1713, 3864, 9, 663, 436, 2931, 2264, 1198, 3688, 1646, 2016, 2219, 4293, 668, 2607, 2221, 3002, 4176, 1110, 4385, 4835, 591, 2951, 479, 2773, 180, 4809, 1484, 2114, 3021, 3966, 1564, 3382, 1971, 4182, 3977, 4087, 2842, 2642, 2790, 3207, 1470, 2903, 4817, 3173, 2887, 1324, 2902, 18, 2440, 3464, 1949, 2021, 3434, 4737, 2366, 3338, 3067, 2724, 4524, 869, 2746, 4215, 451, 1427, 2922, 1899, 2210, 4880, 1890, 1607, 3333, 4219, 1270, 1637, 4896, 3335, 3707, 1011, 476, 1210, 3082, 3323, 1956, 1131, 2426, 4059, 3850, 2529, 1809, 1590, 697, 3467, 1181, 1849, 632, 4752, 1015, 3238, 2129, 3484, 2452, 2664, 2349, 890, 2649, 2330, 3824, 4983, 1743, 526, 17, 4264, 1579, 3180, 1502, 1136, 2068, 1361, 2759, 2486, 76, 2368, 1644, 1156, 3172, 4196, 3455, 1875, 4230, 2945, 3558, 4100, 2502, 2757, 3865, 2904, 60, 500, 4696, 1202, 2662, 1523, 3339, 3597, 741, 1161, 1962, 3433, 4938, 1593, 4565, 1654, 2315, 2333, 1157, 2094, 1995, 1677, 3383, 2298, 2785, 361, 2047, 3035, 1752, 2864, 547, 2492, 2026, 27, 3334, 3825, 1903, 4210, 4618, 1731, 943, 2247, 2434, 885, 350, 4360, 594, 4178, 1257, 202, 882, 610, 3896, 456, 184, 3916, 4599, 596, 4257, 2339, 4957, 4223, 1984, 2835, 3819, 2650, 2213, 1186, 4220, 4799, 536, 160, 317, 1113, 2283, 2601, 1596, 2747, 2354, 3397, 3983, 3325, 3425, 4282, 2393, 1127, 1266, 4986, 3019, 1498, 3201, 1626, 2920, 3208, 3068, 4796, 4895, 2798, 1937, 1139, 888, 1699, 2590, 4485, 2060, 1261, 1760, 2511, 747, 807, 551, 1870, 1618, 3220, 542, 813, 3416, 2164, 4314, 4378, 4744, 225, 1448, 4731, 816, 4848, 4470, 1166, 3779, 703, 970, 1814, 1972, 2669, 1251, 2977, 4630, 4591, 4897, 2187, 3199, 2071, 804, 4504, 2488, 4908, 4211, 396, 306, 3758, 4270, 1556, 2223, 2082, 2957, 4486, 3426, 2905, 1829, 4619, 924, 5000, 559, 1085, 686, 1950, 3545, 1332, 3087, 2, 2364, 721, 49, 4726, 281, 1080, 1689, 3912, 1262, 4419, 4119, 464, 4870, 125, 3439, 370, 3630, 947, 1601, 695, 801, 971, 2140, 3578, 1142, 142, 557, 4972, 3682, 3678, 651, 438, 998, 2148, 521, 1474, 3042, 3902, 1235, 3953, 2290, 1041, 729, 4203, 1981, 3177, 2475, 4312, 2653, 2616, 3735, 4461, 13, 2913, 3026, 2959, 612, 3278, 2947, 2576, 4344, 3391, 988, 2464, 1514, 1254, 23, 4397, 1283, 4723, 3840, 4644, 710, 2459, 4715, 819, 4813, 3284, 1915, 566, 4465, 1121, 4327, 4920, 3083, 724, 4031, 4063, 3385, 1223, 4377, 3179, 2968, 4778, 1377, 4951, 3336, 1219, 4842, 1930, 2183, 1519, 983, 218, 251, 3268, 4700, 1893, 723, 738, 2983, 4717, 3176, 3056, 3719, 2583, 4434, 2429, 2611, 3415, 2671, 4742, 766, 3616, 3063, 2826, 852, 3523, 1264, 360, 1729, 3698, 3753, 1805, 4547, 1360, 1034, 3812, 3668, 3540, 3080, 1951, 2377, 1480, 1615, 318, 754, 3460, 3407, 4304, 3131, 822, 2548, 4441, 3885, 2896, 3893, 3303, 4065, 1766, 1657, 4665, 941, 3160, 1777, 2301, 4593, 1781, 3837, 3877, 3347, 4725, 4918, 1100, 171, 1400, 408, 3141, 4689, 1735, 2544, 3307, 1070, 3644, 3625, 3963, 1343, 4048, 3981, 3361, 1712, 792, 2612, 4399, 2628, 820, 4946, 2520, 2815, 2406, 1575, 430, 457, 304, 4633, 1836, 2805, 1150, 1997, 2718, 263, 2457, 1451, 623, 3894, 473, 4712, 1541, 2316, 166, 3233, 3178, 4278, 4450, 4313, 1390, 2236, 1826, 1507, 1389, 1888, 554, 3827, 276, 2229, 564, 4083, 1550, 7, 267, 1873, 2242, 662, 1621, 4557, 4104, 1935, 3627, 1410, 4374, 4939, 4120, 887, 3194, 1246, 2573, 4008, 3659, 4843, 636, 4999, 3500, 1248, 1066, 2624, 3761, 1273, 1913, 157, 1974, 2859, 3928, 3858, 2690, 4998, 613, 4094, 1489, 3470, 577, 3571, 2451, 4145, 3217, 4052, 4748, 3725, 3061, 1024, 3669, 4774, 2918, 3796, 371, 3072, 3088, 2414, 627, 1864, 1058, 2046, 2241, 345, 1288, 2431, 4876, 277, 2402, 4026, 4057, 3422, 4207, 1748, 2254, 4391, 2535, 4328, 2136, 3299, 4140, 3579, 3453, 4400, 1693, 2458, 735, 2666, 4583, 4623, 3849, 224, 810, 4720, 3122, 2404, 4368, 2906, 2485, 2802, 3899, 4347, 2171, 872, 4738, 4906, 3651, 3978, 133, 4170, 3348, 1378, 878, 385, 380, 1307, 1568, 3929, 1867, 4718, 4701, 440, 550, 4495, 1311, 1813, 3283, 1896, 2603, 2528, 2816, 485, 1294, 4283, 19, 3477, 4850, 3536, 1036, 4670, 4871, 916, 2632, 3869, 2348, 2838, 2582, 1765, 4927, 563, 86, 3798, 1062, 847, 1685, 2465, 247, 158, 1675, 121, 1107, 3982, 1329, 4569, 3828, 655, 1320, 1947, 111, 3352, 3872, 176, 2388, 3353, 3349, 1501, 4890, 1258, 4572, 568, 2715, 2079, 1145, 2626, 2776, 3368, 3193, 1296, 2973, 900, 4707, 4732, 2305, 3243, 3923, 2617, 2289, 343, 1487, 2065, 2894, 1682, 3632, 1744, 4521, 4992, 4855, 322, 1537, 3118, 170, 2053, 122, 894, 3184, 867, 4128, 417, 4667, 3813, 2214, 3502, 1091, 3521, 1583, 1134, 2463, 4798, 4923, 4754, 537, 4889, 2193, 620, 4149, 4445, 3931, 4837, 4954, 4966, 443, 2302, 3730, 3728, 4491, 2428, 3595, 1417, 957, 1645, 3919, 4339, 185, 3823, 4496, 1833, 1573, 1672, 4414, 3633, 3209, 2326, 2622, 481, 3079, 829, 602, 4884, 809, 43, 851, 2673, 3580, 2442, 2963, 2578, 3149, 4180, 2587, 454, 3727, 1586, 2384, 1297, 1609, 3324, 856, 3174, 1543, 2881, 3298, 707, 765, 34, 517, 165, 3437, 2279, 2489, 3596, 1939, 1146, 782, 4117, 2139, 4794, 2296, 3345, 3756, 3732, 3497, 3086, 4160, 2281, 2184, 3424, 402, 3436, 311, 5, 1665, 3984, 1647, 3822, 3046, 2955, 3598, 560, 2762, 1196, 1194, 753, 3961, 4825, 260, 4971, 3650, 3280, 4662, 462, 1614, 3153, 2058, 2144, 592, 2352, 3517, 1364, 3222, 3252, 842, 3116, 3124, 3594, 3577, 3915, 844, 918, 2609, 4426, 4227, 3680, 4492, 3903, 2480, 4683, 1970, 950, 487, 3401, 4963, 2755, 4299, 1393, 3613, 4088, 1803, 126, 4735, 3566, 4779, 2292, 3186, 2523, 1938, 4247, 2115, 1785, 1132, 1850, 66, 2325, 1493, 4418, 3214, 951, 4162, 1249, 2961, 3185, 3866, 3203, 2844, 1453, 4586, 193, 3198, 1512, 1865, 4464, 2032, 4730, 240, 4786, 831, 2043, 3830, 3226, 2360, 2566, 1067, 3689, 2111, 1711, 42, 469, 2251, 2956, 1843, 3246, 3667, 211, 1874, 2163, 1256, 3171, 1250, 1300, 3531, 1174, 1038, 4158, 1931, 383, 1144, 4021, 2153, 4027, 3341, 1542, 3495, 1018, 3619, 2997, 4245, 987, 1429, 2181, 3925, 1237, 4819, 677, 4762, 607, 2646, 2178, 1759, 3459, 3610, 3100, 250, 4839, 226, 2572, 2952, 1819, 2481, 1658, 1199, 1708, 4354, 3354, 48, 3374, 4864, 3505, 4661, 879, 3196, 207, 1839, 1078, 4892, 1572, 4341, 323, 4001, 3032, 2791, 2939, 3400, 2700, 3541, 1039, 600, 4693, 1365, 4757, 523, 422, 4260, 3975, 4858, 1068, 348, 4925, 2647, 1632, 3905, 1499, 3708, 3051, 2675, 3390, 4262, 189, 505, 4195, 4562, 2075, 1447, 1901, 4822, 2056, 4358, 4548, 22, 3620, 2564, 3251, 1986, 1478, 4042, 1832, 4442, 4866, 3695, 268, 1277, 1313, 4714, 1010, 1955, 881, 2514, 3498, 3479, 2877, 1790, 3183, 115, 4371, 985, 4928, 3924, 1914, 227, 412, 1292, 2359, 3729, 315, 3458, 2069, 1396, 4238, 2237, 3104, 1197, 1485, 1755, 2145, 982, 4518, 3590, 1869, 83, 2367, 3269, 3317, 1090, 4568, 893, 1963, 3800, 1053, 1222, 355, 1515, 284, 3775, 825, 997, 803, 727, 2477, 1855, 2846, 3694, 4793, 1608, 63, 3301, 1148, 1431, 3073, 588, 2034, 1205, 1650, 4922, 2588, 2575, 3722, 2585, 709, 4292, 4520, 2694, 1818, 4352, 1351, 4638, 953, 3757, 4660, 3972, 789, 292, 3908, 2362, 97, 2039, 2453, 1373, 2167, 599, 3712, 285, 2987, 3, 1787, 4658, 2394, 1490, 4318, 4578, 3648, 1279, 3150, 4760, 726, 72, 172, 920, 4844, 1831, 3473, 897, 3084, 3991, 212, 2137, 1877, 4389, 3880, 1856, 2077, 3038, 4273, 2604, 1182, 2981, 426, 3075, 2225, 2101, 302, 3759, 1764, 3537, 4044, 1026, 4508, 705, 3375, 3501, 778, 4123, 701, 2487, 4330, 3942, 3255, 3103, 2688, 3282, 4609, 3714, 2439, 519, 2323, 3474, 1009, 2837, 467, 1560, 4645, 4792, 2522, 2954, 4105, 4346, 4058, 3657, 3601, 3762, 2211, 4171, 1540, 4888, 1628, 393, 3859, 2461, 164, 3007, 848, 2832, 3267, 4797, 4614, 1167, 871, 3882, 2192, 986, 3009, 2048, 3490, 2803, 2030, 2215, 2936, 4033, 4401, 1497, 1190, 4342, 575, 1126, 4133, 3013, 3159, 572, 2042, 472, 2445, 4471, 3033, 1401, 1718, 388, 1602, 1547, 4829, 4466, 980, 4165, 4114, 945, 3742, 4513, 2379, 1016, 3643, 1653, 1430, 2966, 4994, 675, 955, 2233, 652, 910, 2446, 2975, 1404, 911, 773, 2462, 4482, 1037, 4007, 486, 2104, 2886, 4874, 4830, 509, 1449, 4082, 4891, 1623, 1750, 3561, 1457, 1881, 4514, 2503, 3911, 3166, 4438, 1231, 3133, 3373, 1463, 748, 1096, 3242, 556, 2871, 1023, 4679, 1455, 4122, 3216, 962, 177, 3509, 1173, 2248, 961, 3739, 3117, 2299, 1844, 4694, 4962, 1028, 1910, 30, 2751, 3554, 4686, 702, 1539, 3449, 4079, 3380, 3815, 1991, 743, 15, 94, 1454, 4681, 4103, 341, 4062, 4549, 2764, 2372, 3039, 4958, 3883, 2262, 664, 4978, 4015, 1247, 3994, 4080, 496, 2856, 788, 4533, 4359 };

            int count = xValues.Length;

            if (count != yValues.Length)
            {
                throw new ArgumentException("Bad data! Number of x values does not equal number of y values");
            }

            //Setup outputs
            var graph = new Dictionary<Point2D, LinkedList<Point2D>>();
            
            //Run
            fortune.GenerateVoronoi(xValues, yValues, count, 0, max, 0, max, minDist);

            //Visual output
            var pixelWidth = 5000;
            var scale = pixelWidth/max;
            System.IO.StreamWriter writer = new System.IO.StreamWriter(@"D:\MyDocs\Documents\output.html");
            writer.WriteLine("<!DOCTYPE html>\n<html>\n<head>\n<title>\nTitle</title>\n</head>\n<body>\n<canvas id=\"myCanvas\" width=\"" + pixelWidth + "\" height=\"" + pixelWidth + "\" style=\"border:1px solid #d3d3d3;\">\nWords"
                    + "</canvas>\n\n<script>\nvar c = document.getElementById(\"myCanvas\");\nvar ctx = c.getContext(\"2d\");\n\n<!--Points-->");

            for (int q = 0; q < count; q++)
            {
                writer.WriteLine("ctx.beginPath();\nctx.arc(" + xValues[q]*scale + "," + yValues[q] * scale + ",1,0,2*Math.PI);\nctx.stroke();\n\n");
            }

            fortune.ResetIterator();
            var line = fortune.GetNext();

            while (line != null)
            {
                writer.WriteLine("ctx.moveTo(" + line[0] * scale + "," + line[1] * scale + ");\nctx.lineTo(" + line[2] * scale + "," + line[3] * scale + ");\nctx.stroke();");
                line = fortune.GetNext();
            }

            writer.WriteLine("</script>\n</body>\n</html>");
            writer.Close();

            //Get cmd output
            fortune.ResetIterator();
            line = fortune.GetNext();

            while (line != null)
            {
                LinkedList<Point2D> temp;

                //	Write to a hash
                //Make Point2D's
                var key1 = new Point2D(line[0], line[1]); //Point 1
                var key2 = new Point2D(line[2], line[3]); //Point 2

                //Put relation
                if (graph.ContainsKey(key1))
                {
                    //Get value, update, put back
                    graph.TryGetValue(key1, out temp);

                    if (temp == null)
                        throw new ArgumentNullException(nameof(temp), "Key was missing for some reason");
                    
                    temp.AddLast(key2);
                    graph.Remove(key1);
                    graph.Add(key1, temp);
                }
                else
                {
                    //Create value, put
                    temp = new LinkedList<Point2D>();
                    temp.AddLast(key2);
                    graph.Add(key1, temp);
                }

                line = fortune.GetNext();
            }
            
            Console.Out.WriteLine("Valid paths:");
            foreach (var key in graph.Keys)
            {
                LinkedList<Point2D> valueList;
                graph.TryGetValue(key, out valueList);

                if (valueList == null)
                    throw new ArgumentNullException(nameof(valueList), "Values not found");

                foreach (var value in valueList)
                {

                    Console.Out.WriteLine("Got line [" + key.X + ", " + key.Y + "] -> [" + value.X + ", " + value.Y + "], ");
                }
            }
        }

        private static double[] GetSet(int max, int size)
        {
            var set = new double[size];

            for (int i = 0; i < size; i++)
            {
                set[i] = new Random().NextDouble() * max;
            }
            return set;
        }

        public bool GenerateVoronoi(double[] xValues, double[] yValues, int numPoints, double minX, double maxX, double minY,
            double maxY, double minDist)
        {
            _minDistanceBetweenSites = minDist;
            _nsites = numPoints;
            _sites = new Site[_nsites];

            //We no longer need min/max like this
            double xmin = xValues[0];
            double ymin = yValues[0];
            double xmax = xValues[0];
            double ymax = yValues[0];

            for (int i = 0; i < _nsites; i++)
            {
                _sites[i] = new Site(new Point2D(xValues[i], yValues[i]));

                if (xValues[i] < xmin)
                    xmin = xValues[i];
                else if (xValues[i] > xmax)
                    xmax = xValues[i];

                if (yValues[i] < ymin)
                    ymin = yValues[i];
                else if (yValues[i] > ymax)
                    ymax = yValues[i];
            }
            //TODO Set max's using image x and y

            // This is where C++ does qsort and some magic stuff to sort these. We
            // do it the hard way. This sort is best-case n and stable, and moreso takes barely any lines

            // Sort x
            for (int n = 1; n < _sites.Length; n++)
            {
                int j = n - 1;
                var tem = _sites[n];
                while (j >= 0 && tem.Coord.X < _sites[j].Coord.X)
                {
                    _sites[j + 1] = _sites[j];
                    j--;
                }
                _sites[j + 1] = tem;
            }

            // Sort y
            for (int n = 1; n < _sites.Length; n++)
            {
                int j = n - 1;
                var tem = _sites[n];
                while (j >= 0 && tem.Coord.Y < _sites[j].Coord.Y)
                {
                    _sites[j + 1] = _sites[j];
                    j--;
                }
                _sites[j + 1] = tem;
            }

            _siteidx = 0;
            Geominit();
            double temp;
            if (minX > maxX)
            {
                temp = minX;
                minX = maxX;
                maxX = temp;
            }
            if (minY > maxY)
            {
                temp = minY;
                minY = maxY;
                maxY = temp;
            }

            _borderMinX = minX;
            _borderMinY = minY;
            _borderMaxX = maxX;
            _borderMaxY = maxY;

            _siteidx = 0;
            Voronoi();

            return true;
        }

        public void ResetIterator() => _iteratorEdges = _allEdges;

        public double[] GetNext()
        {
            var returned = new double[4];

            if (_iteratorEdges == null)
                return null;

            returned[0] = _iteratorEdges.P1.X;
            returned[1] = _iteratorEdges.P1.Y;
            returned[2] = _iteratorEdges.P2.X;
            returned[3] = _iteratorEdges.P2.Y;

            _iteratorEdges = _iteratorEdges.Next;

            return returned;
        }

        private bool ElInitialize()
        {
            int i;
            _elHashsize = 2 * _sqrtNsites;
            _elHash = new Halfedge[_elHashsize];

            for (i = 0; i < _elHashsize; i++) _elHash[i] = null;
            _elLeftend = HEcreate(null, 0);
            _elRightend = HEcreate(null, 0);
            _elLeftend.ElLeft = null;
            _elLeftend.ElRight = _elRightend;
            _elRightend.ElLeft = _elLeftend;
            _elRightend.ElRight = null;
            _elHash[0] = _elLeftend;
            _elHash[_elHashsize - 1] = _elRightend;

            return true;
        }

        private static Halfedge HEcreate(Edge e, int pm)
        {
            var answer = new Halfedge
                         {
                             ElEdge = e,
                             ElPm = pm,
                             PqNext = null,
                             Vertex = null
                         };
            return (answer);
        }

        private static void ElInsert(Halfedge lb, Halfedge newHe)
        {
            newHe.ElLeft = lb;
            newHe.ElRight = lb.ElRight;
            lb.ElRight.ElLeft = newHe;
            lb.ElRight = newHe;
        }

        /* Get entry from hash table, pruning any deleted nodes */

        private Halfedge ElGethash(int b)
        {
            if (b < 0 || b >= _elHashsize)
                return null;

            var he = _elHash[b];

            if (he?.ElEdge == null || he.ElEdge != null)
                return (he);

            /* Hash table points to deleted half edge.  Patch as necessary. */
            _elHash[b] = null;
            return null;
        }

        private Halfedge Leftbnd(Point2D p)
        {
            /* Use hash table to get close to desired halfedge */
            var bucket = (int)(p.X / _deltax * _elHashsize);
            if (bucket < 0) bucket = 0; //make sure that the bucket position in within the range of the hash array
            if (bucket >= _elHashsize) bucket = _elHashsize - 1;

            var he = ElGethash(bucket);
            if (he == null)
            { //if the HE isn't found, search backwards and forwards in the hash map for the first non-null entry
                int i;
                for (i = 1;; i++)
                {
                    if ((he = ElGethash(bucket - i)) != null)
                        break;
                    if ((he = ElGethash(bucket + i)) != null)
                        break;
                }
            }

            /* Now search linear list of halfedges for the correct one */
            if (he == _elLeftend || (he != _elRightend && right_of(he, p)))
            {
                do
                {
                    he = he.ElRight;
                } while (he != _elRightend && right_of(he, p)); //keep going right on the list until either the end is reached, or you find the 1st edge which the point

                he = he.ElLeft; //isn't to the right of
            }
            else
            { //if the point is to the left of the HalfEdge, then search left for the HE just to the left of the point
                do
                {
                    he = he.ElLeft;
                } while (he != _elLeftend && !right_of(he, p));
            }

            /* Update hash table and reference counts */
            if (bucket > 0 && bucket < _elHashsize - 1)
            {
                _elHash[bucket] = he;
            }
            return he;
        }

        /*
         * This delete routine can't reclaim node, since pointers from hash table
         * may be present.
         */

        private void ElDelete(Halfedge he)
        {
            he.ElLeft.ElRight = he.ElRight;
            he.ElRight.ElLeft = he.ElLeft;
            he.ElEdge = null;
        }

        private Site Leftreg(Halfedge he)
        {
            if (he.ElEdge == null)
                return (_bottomsite);
            return (he.ElPm == 0 ? he.ElEdge.Reg[0] : he.ElEdge.Reg[1]);
        }

        private Site Rightreg(Halfedge he)
        {
            if (he.ElEdge == null) //if this halfedge has no edge, return the bottom site (whatever that is)
                return (_bottomsite);

            //if the elPm field is zero, return the site 0 that this edge bisects, otherwise return site number 1
            return (he.ElPm == 0 ? he.ElEdge.Reg[1] : he.ElEdge.Reg[0]);
        }

        private void Geominit()
        {
            var sn = (double)_nsites + 4;
            _sqrtNsites = (int)Math.Sqrt(sn);
            _deltay = _ymax;
            _deltax = _xmax;
        }

        private Edge Bisect(Site s1, Site s2)
        {
            var newedge = new Edge();
       
            newedge.Reg[0] = s1; //store the sites that this edge is bisecting
            newedge.Reg[1] = s2;
            newedge.Ep[0] = null; //to begin with, there are no endpoints on the bisector - it goes to infinity
            newedge.Ep[1] = null;

            var dx = s2.Coord.X - s1.Coord.X;
            var dy = s2.Coord.Y - s1.Coord.Y;
            var adx = dx > 0 ? dx : -dx;
            var ady = dy > 0 ? dy : -dy;
            newedge.C = s1.Coord.X * dx + s1.Coord.Y * dy + (dx * dx + dy * dy) * 0.5; //get the slope of the line

            if (adx > ady)
            {
                newedge.A = 1.0;
                newedge.B = dy / dx;
                newedge.C /= dx; //set formula of line, with x fixed to 1
            }
            else
            {
                newedge.B = 1.0;
                newedge.A = dx / dy;
                newedge.C /= dy; //set formula of line, with y fixed to 1
            }
            
            //printf("\nbisect(%d) ((%f,%f) and (%f,%f)",nedges,s1.coord.x,s1.coord.y,s2.coord.x,s2.coord.y);

            return (newedge);
        }

        // create a new site where the HalfEdges el1 and el2 intersect - note that
        // the Point in the argument list is not used, don't know why it's there
        private Site Intersect(Halfedge el1, Halfedge el2)
        {
            Edge e;
            Halfedge el;

            var e1 = el1.ElEdge;
            var e2 = el2.ElEdge;
            if (e1 == null || e2 == null || e1.Reg[1] == e2.Reg[1])
                return null;

            var d = (e1.A * e2.B) - (e1.B * e2.A);
            //This checks for the value being basically zero
            if (-0.0000000001 < d && d < 0.0000000001)
                return null;

            var xint = (e1.C * e2.B - e2.C * e1.B) / d;
            var yint = (e2.C * e1.A - e1.C * e2.A) / d;

            if ((e1.Reg[1].Coord.Y < e2.Reg[1].Coord.Y) || (DblEql(e1.Reg[1].Coord.Y, e2.Reg[1].Coord.Y) &&
                                                              e1.Reg[1].Coord.X < e2.Reg[1].Coord.X))
            {
                el = el1;
                e = e1;
            }
            else
            {
                el = el2;
                e = e2;
            }

            if ((xint >= e.Reg[1].Coord.X && el.ElPm == 0) || (xint < e.Reg[1].Coord.X && el.ElPm == 1))
                return null;

            //create a new site at the point of intersection - this is a new vector event waiting to happen
            return new Site(new Point2D(xint, yint));
        }

        /* returns 1 if p is to right of halfedge e */

        private static bool right_of(Halfedge el, Point2D p)
        {
            bool above;

            var e = el.ElEdge;
            var topsite = e.Reg[1];
            var rightOfSite = p.X > topsite.Coord.X;
            if (rightOfSite && el.ElPm == 0)
                return (true);
            if (!rightOfSite && el.ElPm == 1)
                return (false);

            if (DblEql(e.A, 1.0))
            {
                var dyp = p.Y - topsite.Coord.Y;
                var dxp = p.X - topsite.Coord.X;
                var fast = false;
                if ((!rightOfSite && (e.B < 0.0)) || (rightOfSite && (e.B >= 0.0)))
                {
                    above = dyp >= e.B * dxp;
                    fast = above;
                }
                else
                {
                    above = p.X + p.Y * e.B > e.C;
                    if (e.B < 0.0)
                        above = !above;
                    if (!above)
                        fast = true;
                }

                if (fast) return (el.ElPm == 0 ? above : !above);
                var dxs = topsite.Coord.X - (e.Reg[0]).Coord.X;
                above = e.B * (dxp * dxp - dyp * dyp) < dxs * dyp * (1.0 + 2.0 * dxp / dxs + e.B * e.B);
                if (e.B < 0.0)
                    above = !above;
            }
            else
            {
                var yl = e.C - e.A * p.X;
                var t1 = p.Y - yl;
                var t2 = p.X - topsite.Coord.X;
                var t3 = yl - topsite.Coord.Y;
                above = t1 * t1 > t2 * t2 + t3 * t3;
            }
            return (el.ElPm == 0 ? above : !above);
        }

        private void Endpoint(Edge e, int lr, Site s)
        {
            e.Ep[lr] = s;
            if (e.Ep[1 - lr] == null)
                return;
            
            clip_line(e);
        }

        // push the HalfEdge into the ordered linked list of vertices
        private void PQinsert(Halfedge he, Site v, double offset)
        {
            Halfedge next;

            he.Vertex = v;
            he.YStar = v.Coord.Y + offset;
            var last = _pqHash[PQbucket(he)];
            while ((next = last.PqNext) != null && (he.YStar > next.YStar || (DblEql(he.YStar, next.YStar) && v.Coord.X > next.Vertex.Coord.X)))
            {
                last = next;
            }

            he.PqNext = last.PqNext;
            last.PqNext = he;
            _pqCount++;
        }

        // remove the HalfEdge from the list of vertices
        //Returns the input edge so we can shave space on a few methods
        private Halfedge PQdelete(Halfedge he)
        {
            if (he.Vertex == null) return he;
            var last = _pqHash[PQbucket(he)];
            while (last.PqNext != he)
                last = last.PqNext;

            last.PqNext = he.PqNext;
            _pqCount -= 1;
            he.Vertex = null;
            return he;
        }

        private int PQbucket(Halfedge he)
        {
            var bucket = (int)(he.YStar / _deltay * _pqHashsize);
            if (bucket < 0)
                bucket = 0;
            if (bucket >= _pqHashsize)
                bucket = _pqHashsize - 1;
            if (bucket < _pqMin)
                _pqMin = bucket;
            return bucket;
        }

        private bool PQempty() => (_pqCount == 0);

        private Point2D PQ_min()
        {
            while (_pqHash[_pqMin].PqNext == null)
                _pqMin += 1;

            return new Point2D(_pqHash[_pqMin].PqNext.Vertex.Coord.X, _pqHash[_pqMin].PqNext.YStar);
        }

        private Halfedge PQextractmin()
        {
            var curr = _pqHash[_pqMin].PqNext;
            _pqHash[_pqMin].PqNext = curr.PqNext;
            _pqCount -= 1;
            return curr;
        }

        private void PQinitialize()
        {
            int i;

            _pqCount = 0;
            _pqMin = 0;
            _pqHashsize = 4 * _sqrtNsites;
            _pqHash = new Halfedge[_pqHashsize];

            if (_pqHash == null)
                return;

            for (i = 0; i < _pqHashsize; i++)
            {
                _pqHash[i] = new Halfedge {PqNext = null};
            }
        }

        private void PushGraphEdge(double x1, double y1, double x2, double y2)
        {
            var newEdge = new GraphEdge(new Point2D(x1, y1), new Point2D(x2, y2), _allEdges);
            _allEdges = newEdge;
        }

        private void clip_line(Edge e)
        {
            Site s1, s2;

            var x1 = e.Reg[0].Coord.X;
            var x2 = e.Reg[1].Coord.X;
            var y1 = e.Reg[0].Coord.Y;
            var y2 = e.Reg[1].Coord.Y;

            //if the distance between the two points this line was created from is less than 
            //the square root of 2, then ignore it
            if (Math.Sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) < _minDistanceBetweenSites) return;

            _pxmin = _borderMinX;
            _pxmax = _borderMaxX;
            _pymin = _borderMinY;
            _pymax = _borderMaxY;

            if (DblEql(e.A, 1.0) && e.B >= 0.0)
            {
                s1 = e.Ep[1];
                s2 = e.Ep[0];
            }
            else
            {
                s1 = e.Ep[0];
                s2 = e.Ep[1];
            }

            if (DblEql(e.A, 1.0))
            {
                y1 = _pymin;
                if (s1 != null && s1.Coord.Y > _pymin)
                    y1 = s1.Coord.Y;

                if (y1 > _pymax)
                    y1 = _pymax;

                x1 = e.C - e.B * y1;
                y2 = _pymax;
                if (s2 != null && s2.Coord.Y < _pymax)
                    y2 = s2.Coord.Y;

                if (y2 < _pymin)
                    y2 = _pymin;

                x2 = e.C - e.B * y2;
                if (((x1 > _pxmax) && (x2 > _pxmax)) || ((x1 < _pxmin) && (x2 < _pxmin)))
                    return;

                if (x1 > _pxmax)
                {
                    x1 = _pxmax;
                    y1 = (e.C - x1) / e.B;
                }

                if (x1 < _pxmin)
                {
                    x1 = _pxmin;
                    y1 = (e.C - x1) / e.B;
                }

                if (x2 > _pxmax)
                {
                    x2 = _pxmax;
                    y2 = (e.C - x2) / e.B;
                }

                if (x2 < _pxmin)
                {
                    x2 = _pxmin;
                    y2 = (e.C - x2) / e.B;
                }
            }
            else
            {
                x1 = _pxmin;
                if (s1 != null && s1.Coord.X > _pxmin)
                    x1 = s1.Coord.X;

                if (x1 > _pxmax)
                    x1 = _pxmax;

                y1 = e.C - e.A * x1;
                x2 = _pxmax;
                if (s2 != null && s2.Coord.X < _pxmax)
                    x2 = s2.Coord.X;

                if (x2 < _pxmin)
                    x2 = _pxmin;

                y2 = e.C - e.A * x2;

                if (((y1 > _pymax) & (y2 > _pymax)) | ((y1 < _pymin) & (y2 < _pymin)))
                    return;

                if (y1 > _pymax)
                {
                    y1 = _pymax;
                    x1 = (e.C - y1) / e.A;
                }

                if (y1 < _pymin)
                {
                    y1 = _pymin;
                    x1 = (e.C - y1) / e.A;
                }

                if (y2 > _pymax)
                {
                    y2 = _pymax;
                    x2 = (e.C - y2) / e.A;
                }

                if (y2 < _pymin)
                {
                    y2 = _pymin;
                    x2 = (e.C - y2) / e.A;
                }
            }

            PushGraphEdge(x1, y1, x2, y2);
        }

        /*
         * implicit parameters: nsites, sqrt_nsites, xmin, xmax, ymin, ymax, deltax,
         * deltay (can all be estimates). Performance suffers if they are wrong;
         * better to make nsites, deltax, and deltay too big than too small. (?)
         */

        private void Voronoi()
        {
            Point2D newintstar = null;
            Halfedge lbnd;
    
            PQinitialize();
            _bottomsite = Nextone();
            bool retval = ElInitialize();

            if (!retval)
                return;

            var newsite = Nextone();

            while (true)
            {
                if (!PQempty())
                    newintstar = PQ_min();

                //if the lowest site has a smaller y value than the lowest vector intersection, process the site
                //otherwise process the vector intersection		

                Site bot;
                Site p;
                Halfedge rbnd;
                Halfedge bisector;
                Edge e;
                if (newsite != null && (PQempty() || newsite.Coord.Y < newintstar.Y || (DblEql(newsite.Coord.Y, newintstar.Y) && newsite.Coord.X < newintstar.X)))
                { /* new site is smallest - this is a site event*/
                    //out_site(newsite);						//output the site
                    lbnd = Leftbnd(newsite.Coord); //get the first HalfEdge to the LEFT of the new site
                    rbnd = lbnd.ElRight; //get the first HalfEdge to the RIGHT of the new site
                    bot = Rightreg(lbnd); //if this halfedge has no edge, , bot = bottom site (whatever that is)
                    e = Bisect(bot, newsite); //create a new edge that bisects 
                    bisector = HEcreate(e, 0); //create a new HalfEdge, setting its elPm field to 0			
                    ElInsert(lbnd, bisector); //insert this new bisector edge between the left and right vectors in a linked list	

                    if ((p = Intersect(lbnd, bisector)) != null)//if the new bisector intersects with the left edge, remove the left edge's vertex, and put in the new one
                        PQinsert(PQdelete(lbnd), p, p.Coord.Distance(newsite.Coord));

                    lbnd = bisector;
                    bisector = HEcreate(e, 1); //create a new HalfEdge, setting its elPm field to 1
                    ElInsert(lbnd, bisector); //insert the new HE to the right of the original bisector earlier in the IF stmt

                    if ((p = Intersect(bisector, rbnd)) != null)//if this new bisector intersects with the
                        PQinsert(bisector, p, p.Coord.Distance(newsite.Coord)); //push the HE into the ordered linked list of vertices

                    newsite = Nextone();
                }
                else if (!PQempty())
                { /* intersection is smallest - this is a vector event */
                    lbnd = PQextractmin(); //pop the HalfEdge with the lowest vector off the ordered list of vectors				
                    var llbnd = lbnd.ElLeft;
                    rbnd = lbnd.ElRight; //get the HalfEdge to the right of the above HE
                    var rrbnd = rbnd.ElRight;
                    bot = Leftreg(lbnd); //get the Site to the left of the left HE which it bisects
                    var top = Rightreg(rbnd);

                    var v = lbnd.Vertex;
                    Endpoint(lbnd.ElEdge, lbnd.ElPm, v); //set the endpoint of the left HalfEdge to be this vector
                    Endpoint(rbnd.ElEdge, rbnd.ElPm, v); //set the endpoint of the right HalfEdge to be this vector
                    ElDelete(lbnd); //mark the lowest HE for deletion - can't delete yet because there might be pointers to it in Hash Map	
                    PQdelete(rbnd); //remove all vertex events to do with the  right HE
                    ElDelete(rbnd); //mark the right HE for deletion - can't delete yet because there might be pointers to it in Hash Map	
                    var pm = 0;

                    if (bot.Coord.Y > top.Coord.Y)
                    { //if the site to the left of the event is higher than the Site to the right of it, then swap them and set the 'pm' variable to 1
                        var temp = bot;
                        bot = top;
                        top = temp;
                        pm = 1;
                    }

                    e = Bisect(bot, top); //create an Edge (or line) that is between the two Sites. This creates
                    //the formula of the line, and assigns a line number to it
                    bisector = HEcreate(e, pm); //create a HE from the Edge 'e', and make it point to that edge with its elEdge field
                    ElInsert(llbnd, bisector); //insert the new bisector to the right of the left HE
                    Endpoint(e, 1 - pm, v); //set one endpoint to the new edge to be the vector point 'v'.
                    //If the site to the left of this bisector is higher than the right
                    //Site, then this endpoint is put in position 0; otherwise in pos 1

                    //if left HE and the new bisector don't intersect, then delete the left HE, and reinsert it 
                    if ((p = Intersect(llbnd, bisector)) != null)
                        PQinsert(PQdelete(llbnd), p, p.Coord.Distance(bot.Coord));

                    //if right HE and the new bisector don't intersect, then reinsert it 
                    if ((p = Intersect(bisector, rrbnd)) != null)
                        PQinsert(bisector, p, p.Coord.Distance(bot.Coord));
                }
                else break;
            }


            for (lbnd = _elLeftend.ElRight; lbnd != _elRightend; lbnd = lbnd.ElRight)
                clip_line(lbnd.ElEdge);
        }

        private static bool DblEql(double a, double b) => Math.Abs(a - b) < 0.00000000001;

        /* return a single in-storage site */
        private Site Nextone()
        {
            if (_siteidx >= _nsites) return null;
            _siteidx ++;
            return _sites[_siteidx-1];
        }
    }
}